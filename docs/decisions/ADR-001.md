# ADR-001: OriJS Framework Design Decisions

## Status

Accepted

## Context

OriJS is a lightweight NestJS-inspired framework running on Bun, designed for performance and simplicity. This ADR consolidates all architectural decisions made during framework development and code review (2026-01-10).

---

## Part 1: Core Design Principles

1. **BullMQ handles distributed coordination** - Leverage BullMQ's built-in features rather than reimplementing
2. **Callers are responsible for their inputs** - Framework validates structure, callers validate content
3. **API boundary handles sanitization** - Internal errors preserve context; controllers sanitize for clients
4. **Simple over complex** - Avoid adding abstractions until needed (YAGNI)
5. **Single-threaded event loop** - JavaScript's event loop prevents race conditions; no locks needed

---

## Part 2: Fluent API Pattern

### Decision

Use fluent builder APIs for complex configuration objects that have required/optional parameters in specific order and benefit from compile-time enforcement.

### Rationale

1. **Compile-time enforcement**: Staged interfaces ensure required methods called before `build()`
2. **Self-documenting**: Method names describe what each value does
3. **Human-readable durations**: `.ttl('5m')` clearer than `ttl: 300`
4. **Registry integration**: Builders auto-derive values from context

### Implementation

```typescript
// Staged interfaces enforce order
interface CacheBuilderForEntity<T> {
	ttl(duration: Duration): CacheBuilderWithTtl<T>;
}

interface CacheBuilderWithTtl<T> {
	grace(duration: Duration): CacheBuilderWithTtl<T>;
	build(): Readonly<CacheConfig<T>>;
}

// Usage
Cache.for(Entities.Product).ttl('5m').grace('1m').build();
```

### When NOT to Use

- Simple configuration with few options (use constructor)
- Internal APIs rarely used by consumers
- Performance-critical code paths

---

## Part 3: Transport Interface

### Decision

Make `flush()` and `close()` required methods on `Transport` interface.

### Context

Logger.shutdown() was sync and didn't await transport cleanup, risking log loss.

### Implementation

```typescript
export interface Transport {
  write(obj: LogObject): void;
  flush(): Promise<void>;  // Required
  close(): Promise<void>;  // Required
}

static async shutdown(): Promise<void> {
  for (const transport of transports) {
    await transport.flush();
    await transport.close();
  }
}
```

### Consequences

- Breaking change for custom transports (must add methods)
- Guaranteed log delivery on graceful shutdown

---

## Part 4: Workflow & Event System

### D1: No Step-Level Idempotency in Framework

Step idempotency is handler responsibility. BullMQ provides job-level idempotency via jobId; handlers implement domain-specific idempotency.

### D2: Event Idempotency via BullMQ Job IDs

Added `idempotencyKey` to `EmitOptions`. BullMQ provider passes as `jobId` for Redis-based deduplication across distributed workers.

### D3: FlowStateManager is Single-Process Only

Uses in-memory Maps for InProcessWorkflowProvider (testing). BullMQWorkflowProvider uses Redis via BullMQ job tree.

### D4: No Framework-Level Circuit Breakers

Step handlers call external services and know failure modes. BullMQ provides retry/backoff. Framework circuit breaker too generic.

### D5: Saga State Lives in BullMQ

Workflow state in BullMQ job tree, not separate saga store. `job.getChildrenValues()` retrieves completed results.

### D6: Error Sanitization at API Boundary

Internal errors preserve full context. Controllers sanitize for clients.

### D7: Rate Limiting via BullMQ

Use BullMQ's `limiter` option, not custom implementation.

### D8: No Distributed Locks for Rollback

BullMQ jobs processed by exactly one worker. Rollbacks run as part of job processing.

---

## Part 5: Rejected Patterns

These patterns were explicitly rejected during code review:

| Pattern                          | Reason                                       |
| -------------------------------- | -------------------------------------------- |
| RFC 7807 error format            | Optional standard; current format consistent |
| Framework-level rate limiting    | Application/infrastructure concern           |
| Framework-level CORS             | Infrastructure concern (reverse proxy)       |
| Response schema validation       | TypeScript provides compile-time safety      |
| Built-in metrics/observability   | External APM tools provide this              |
| Request timeouts in framework    | Bun.serve has idle timeout                   |
| Location header on 201           | Application-specific URL structure           |
| Event naming validation          | TypeScript compile-time safety               |
| "Manager" â†’ "Coordinator" rename | Breaking change, no functional benefit       |
| Interface "I" prefix removal     | Internal, breaking change for style          |

---

## Part 6: Validated Patterns

These patterns were confirmed correct:

| Pattern                               | Validation                     |
| ------------------------------------- | ------------------------------ |
| `console.error` in framework-error.ts | Runs before Logger configured  |
| ChainedBuilder inheritance            | Shared finalization behavior   |
| Object.create(null) for queries       | Prevents prototype pollution   |
| Coordinator naming                    | Valid domain terminology       |
| Singleflight 100ms suppression        | Bounded by concurrent requests |
| JavaScript single-threaded model      | No mutex needed for Map ops    |
| Phantom types for DI tokens           | Standard TypeScript pattern    |

---

## Part 7: Code Review Summary (2026-01-10)

| Status  | Count |
| ------- | ----- |
| FIXED   | 45    |
| INVALID | 124   |
| OPEN    | 0     |

**Key Fixes**:

- Transport flush/close required (#101)
- Event idempotency via BullMQ (#1)
- Redis cleanup label filtering (#2)
- Test infrastructure improvements (#3-45)

---

## Consequences

### Positive

- Simple framework with clear boundaries
- Leverages BullMQ's battle-tested features
- 2252+ tests passing
- Production-ready architecture

### Negative

- Step handlers must implement own idempotency
- Callers must handle input validation
- Controllers must sanitize errors
- Transport interface breaking change

---

## References

- BullMQ FlowProducer documentation
- Martin Fowler: "FluentInterface"
- Effective Java, Item 2: Builder pattern
- Code review: `docs/work/code-review/code_review_2026-01-10_frameworks-orijs.md`
- ADR-006: Type system patterns (consumer pattern code review)

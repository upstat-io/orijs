//! OriJS AOT Compiler
//!
//! Generates optimized route handlers at build time.
//! Eliminates runtime conditionals by generating route-specific code.
//!
//! Usage:
//!   orijs-compile --manifest routes.json --out compiled-handlers.ts
//!
//! The manifest is generated by OriJS during a prebuild step.

use anyhow::{Context, Result};
use clap::Parser;
use std::fs;
use std::path::PathBuf;

#[derive(Parser, Debug)]
#[command(name = "orijs-compile")]
#[command(about = "AOT compiler for OriJS route handlers")]
struct Args {
    /// Path to route manifest JSON
    #[arg(short, long)]
    manifest: PathBuf,

    /// Output TypeScript file
    #[arg(short, long)]
    out: PathBuf,
}

/// Route definition from the manifest
#[derive(Debug, serde::Deserialize)]
struct RouteManifest {
    routes: Vec<Route>,
}

#[derive(Debug, serde::Deserialize)]
struct Route {
    /// Full path like "/api/users/:id"
    path: String,
    /// HTTP method
    method: String,
    /// Controller class name
    controller: String,
    /// Handler method name
    handler: String,
    /// Guard class names (in order)
    guards: Vec<String>,
    /// Whether route has schema validation
    has_schema: bool,
    /// Whether route has interceptors
    has_interceptors: bool,
}

fn main() -> Result<()> {
    let args = Args::parse();

    // Read manifest
    let manifest_content = fs::read_to_string(&args.manifest)
        .with_context(|| format!("Failed to read manifest: {:?}", args.manifest))?;

    let manifest: RouteManifest = serde_json::from_str(&manifest_content)
        .with_context(|| "Failed to parse manifest JSON")?;

    // Generate optimized handlers
    let output = generate_handlers(&manifest);

    // Write output
    fs::write(&args.out, output)
        .with_context(|| format!("Failed to write output: {:?}", args.out))?;

    println!(
        "âœ“ Compiled {} routes to {:?}",
        manifest.routes.len(),
        args.out
    );

    Ok(())
}

/// Generates optimized TypeScript handler code
fn generate_handlers(manifest: &RouteManifest) -> String {
    let mut output = String::new();

    // File header
    output.push_str(r#"/**
 * AUTO-GENERATED by orijs-compile
 * DO NOT EDIT - Changes will be overwritten
 *
 * This file contains AOT-compiled route handlers with:
 * - No runtime conditionals
 * - Inlined guard checks
 * - Optimized code paths
 */

import type { BunRequest } from '@orijs/core';
import { ResponseFactory } from '@orijs/core';

const responseFactory = new ResponseFactory();

"#);

    // Generate each handler
    for route in &manifest.routes {
        output.push_str(&generate_handler(route));
        output.push_str("\n\n");
    }

    // Export map
    output.push_str("// Route handler map for runtime registration\n");
    output.push_str("export const compiledHandlers = new Map<string, (req: BunRequest) => Promise<Response>>([\n");
    for route in &manifest.routes {
        let key = format!("{}:{}", route.method, route.path);
        let fn_name = handler_fn_name(route);
        output.push_str(&format!("  ['{}', {}],\n", key, fn_name));
    }
    output.push_str("]);\n");

    output
}

/// Generates an optimized handler for a single route
fn generate_handler(route: &Route) -> String {
    let fn_name = handler_fn_name(route);
    let mut code = String::new();

    // Function signature
    code.push_str(&format!(
        "/**\n * {} {}\n * Controller: {}\n * Guards: {}\n */\n",
        route.method,
        route.path,
        route.controller,
        if route.guards.is_empty() {
            "none".to_string()
        } else {
            route.guards.join(", ")
        }
    ));

    code.push_str(&format!(
        "export async function {}(req: BunRequest, ctx: any, guards: any[], handler: any): Promise<Response> {{\n",
        fn_name
    ));

    // --- BEGIN GENERATED BODY ---

    // Guard checks - UNROLLED, no loop at runtime
    if !route.guards.is_empty() {
        for (i, guard_name) in route.guards.iter().enumerate() {
            code.push_str(&format!(
                r#"  // Guard {}: {}
  if (!(await guards[{}].canActivate(ctx))) {{
    return responseFactory.forbidden();
  }}
"#,
                i, guard_name, i
            ));
        }
    }

    // Schema validation - only if route has schema
    if route.has_schema {
        code.push_str(
            r#"  // Schema validation
  const validationResult = await ctx.validateSchema();
  if (!validationResult.success) {
    return responseFactory.validationError(validationResult.errors);
  }
"#,
        );
    }

    // Interceptors - only if route has interceptors
    if route.has_interceptors {
        code.push_str(
            r#"  // Interceptor chain
  return await executeInterceptorChain(ctx, handler);
"#,
        );
    } else {
        // Direct handler call - no interceptor overhead
        code.push_str(
            r#"  // Direct handler call (no interceptors)
  return await handler(ctx);
"#,
        );
    }

    code.push_str("}\n");

    code
}

/// Generates a unique function name for the handler
fn handler_fn_name(route: &Route) -> String {
    let path_clean = route
        .path
        .replace('/', "_")
        .replace(':', "p_")
        .replace('-', "_");
    format!(
        "handle_{}_{}",
        route.method.to_lowercase(),
        path_clean.trim_start_matches('_')
    )
}
